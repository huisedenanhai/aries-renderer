#version 450 core

#include <MetallicRoughnessPBR.glsl>
#include <Misc.glsl>
#include <Sampling.glsl>

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform samplerCube radiance_cube_map;

layout(set = 1, binding = 0) uniform Param {
    int size;
    float perceptual_roughness;
    int mip_level;
    int radiance_base_resolution;
};
layout(set = 1, binding = 1, r11f_g11f_b10f) uniform imageCube cube_map;

void main() {
    ivec3 index = ivec3(gl_GlobalInvocationID.xyz);
    if (index.x >= size || index.y >= size) {
        return;
    }
    vec3 n = cube_map_index_to_direction(index, size);
    vec3 t, b;
    construct_TBN_with_normal(n, t, b);

    vec3 acc = vec3(0.0);
    float weight = 0.0;

    float roughness = square(perceptual_roughness);

    int sample_count = 512;
    for (int i = 0; i < sample_count; i++) {
        vec2 u = hammersly(i, sample_count);
        vec3 h = sample_h_from_D(roughness, u);
        vec3 r = reflect(vec3(0, -1, 0), h);
        if (r.y > 0) {
            vec3 dir = r.y * n + r.x * t + r.z * b;

            // Access mipmap based on sample density
            // https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/
            float D = D_GGX(h.y, roughness);
            float pdf = (D * h.y / (4 * h.y)) + 0.0001;

            float sa_texel =
                4.0 * PI /
                (6.0 * radiance_base_resolution * radiance_base_resolution);
            float sa_sample = 1.0 / (sample_count * pdf + 0.00001);

            float env_mip_level =
                roughness == 0.0 ? 0.0 : 0.5 * log2(sa_sample / sa_texel);

            acc += textureLod(radiance_cube_map, dir, env_mip_level).rgb * r.y;
            weight += r.y;
        }
    }

    imageStore(cube_map, index, vec4(max(acc / weight, vec3(0.0)), 1.0));
}