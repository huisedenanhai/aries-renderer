#version 450 core

#include <GBuffer.glsl>
#include <Misc.glsl>
#include <Transform.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0,
       binding = 0,
       r11f_g11f_b10f) writeonly uniform image2D output_color_image;

layout(set = 0, binding = 1) uniform sampler2D hiz_buffer;
layout(set = 0, binding = 2) uniform sampler2D src_color_tex;
layout(set = 0, binding = 3) uniform sampler2D gbuffer0_tex;
layout(set = 0, binding = 4) uniform sampler2D gbuffer1_tex;
layout(set = 0, binding = 5) uniform sampler2D gbuffer2_tex;

layout(set = 1, binding = 0) uniform Param {
    mat4 P;
    mat4 I_P;
    int width;
    int height;
    int hiz_mip_count;
};

layout(set = 1, binding = 1, std430) buffer MipLevels {
    vec2 mip_resolutions[];
};

// Aries uses reverse Z, near plane maps to 1 and far plane maps to 0 in screen
// space.
// Given a ray in grid's local coordinate, calculate the hit distance t.
// The origin MUST be inside the grid.
bool trace_ray_hit_grid(vec3 origin,
                        vec3 dir,
                        vec2 grid_size,
                        float grid_height,
                        vec2 border_offset,
                        out float t) {
    // Hit the height plane
    float t0 = (grid_height - origin.z) / dir.z;
    // Ray already under the grid, no need to trace
    t0 = origin.z <= grid_height ? 0 : t0;

    // Hit border
    float bx = dir.x > 0 ? grid_size.x : 0.0;
    float by = dir.y > 0 ? grid_size.y : 0.0;
    // Add some offset to pad the grid bigger so the ray can go into the
    // neighbor grid, otherwise the ray will keep stepping the same grid due to
    // float point precision issue.
    vec2 b = vec2(bx, by) + border_offset;
    vec2 tb = (b - origin.xy) / dir.xy;
    // t1 >= 0.0 if the origin is inside the grid.
    float t1 = min(tb.x, tb.y);

    t = min(t0, t1);
    // t0 < 0 means no hit happens with height plane
    t = t0 < 0 ? t1 : t;

    return t == t0;
}

bool trace_ray_hiz(vec3 origin_ss,
                   vec3 dir_ss,
                   int start_mip_level,
                   out vec3 hit_ss) {
    int root_level = hiz_mip_count - 1;
    start_mip_level = min(start_mip_level, root_level);
    int level = start_mip_level;

    vec2 start_mip_res = mip_resolutions[start_mip_level];
    vec2 start_grid_size = 1.0 / start_mip_res;

    vec2 border_offset = sign(dir_ss.xy) * start_grid_size * 1e-3;

    hit_ss = origin_ss;
    // step one grid to avoid self intersection
    {
        vec2 mip_res = start_mip_res;
        vec2 grid_size = start_grid_size;
        vec2 grid_index = floor(hit_ss.xy * mip_res);
        vec3 grid_offset_ss = vec3(grid_index * grid_size, 0.0);

        float t = 0;
        trace_ray_hit_grid(
            hit_ss - grid_offset_ss, dir_ss, grid_size, 0.0, border_offset, t);
        hit_ss += t * dir_ss;
    }

    int iter = 0;
    // The max iter count only works as a safety guard from the kernel stalling
    // the GPU. Decrease it will results in missing ray tracing hits.
    const int MAX_ITER_COUNT = 400;

    // Only check if the ray hits near/far plane, rather than do a full check if
    // hit point is inside screen. As full check takes too much time according
    // to the profiler.
    while (iter < MAX_ITER_COUNT && level >= start_mip_level &&
           level <= root_level && value_in_01(hit_ss.z)) {
        vec2 mip_res = mip_resolutions[level];
        vec2 grid_size = 1.0 / mip_res;
        vec2 grid_index = floor(hit_ss.xy * mip_res);
        vec3 grid_offset_ss = vec3(grid_index * grid_size, 0.0);

        float t = 0;
        bool has_hit =
            trace_ray_hit_grid(hit_ss - grid_offset_ss,
                               dir_ss,
                               grid_size,
                               // HiZ buffer uses nearest filtering, there is no
                               // need to calculate grid center explicitly
                               textureLod(hiz_buffer, hit_ss.xy, level).r,
                               border_offset,
                               t);
        hit_ss += t * dir_ss;

        level += has_hit ? -1 : 1;
        iter++;
    }

    return level < start_mip_level;
}

// Very slow for long range ray, only used as a simple reference during
// development
bool trace_ray_dda(vec3 origin_ss,
                   vec3 dir_ss,
                   int mip_level,
                   out vec3 hit_ss) {
    vec2 mip_res = mip_resolutions[mip_level];
    vec2 grid_size = 1.0 / mip_res;
    vec2 border_offset = sign(dir_ss.xy) * grid_size * 1e-3;
    hit_ss = origin_ss;

    // step one grid to avoid self intersection
    {
        vec2 grid_index = floor(hit_ss.xy * mip_res);
        vec3 grid_offset_ss = vec3(grid_index * grid_size, 0.0);

        float t = 0;
        trace_ray_hit_grid(
            hit_ss - grid_offset_ss, dir_ss, grid_size, 0.0, border_offset, t);
        hit_ss += t * dir_ss;
    }

    for (int i = 0; i < 300; i++) {
        vec2 grid_index = floor(hit_ss.xy * mip_res);
        vec3 grid_offset_ss = vec3(grid_index * grid_size, 0.0);
        vec2 grid_center_uv = index_to_uv(grid_index, grid_size);

        float t = 0;
        bool has_hit = trace_ray_hit_grid(
            hit_ss - grid_offset_ss,
            dir_ss,
            grid_size,
            textureLod(hiz_buffer, grid_center_uv, mip_level).r,
            border_offset,
            t);
        hit_ss += t * dir_ss;

        if (has_hit) {
            return true;
        }
    }
    return false;
}

vec3 calculate_color(ivec2 index) {
    vec2 uv = index_to_uv(index, vec2(1.0 / width, 1.0 / height));

    float depth01 = textureLod(hiz_buffer, uv, 0).r;
    if (depth01 == 0) {
        return texture(src_color_tex, uv).rgb;
    }

    GBuffer gbuffer = decode_gbuffer(texture(gbuffer0_tex, uv),
                                     texture(gbuffer1_tex, uv),
                                     texture(gbuffer2_tex, uv),
                                     vec4(0));
    int start_mip_level = 0;
    // Correct z to avoid self intersection
    depth01 = textureLod(hiz_buffer, uv, start_mip_level).r;

    vec3 pos_vs = reconstruct_position_from_ss(I_P, uv, depth01);
    vec3 view_dir_vs = -normalize(pos_vs);
    vec3 reflect_dir_vs = normalize(reflect(-view_dir_vs, gbuffer.normal_vs));

    vec3 pos_ss = vec3(uv, depth01);
    vec3 offset_pos_ss =
        transform_position_hclip_to_ss(P * vec4(pos_vs + reflect_dir_vs, 1.0));
    vec3 reflect_dir_ss = offset_pos_ss - pos_ss;

    vec3 hit_ss;
    bool has_hit =
        trace_ray_hiz(pos_ss, reflect_dir_ss, start_mip_level, hit_ss);
    // bool has_hit = trace_ray_dda(pos_ss, reflect_dir_ss, start_mip_level,
    // hit_ss);

    return texture(src_color_tex, hit_ss.xy).rgb * (has_hit ? 1.0 : 0.0);
}

void main() {
    ivec2 index = ivec2(gl_GlobalInvocationID.xy);
    if (index.x >= width || index.y >= height) {
        return;
    }

    vec3 color = calculate_color(index);

    imageStore(output_color_image, index, vec4(color, 1.0));
}