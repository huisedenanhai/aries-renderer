#version 450 core

#include <GBuffer.glsl>
#include <Light.glsl>
#include <MetallicRoughnessPBR.glsl>
#include <Misc.glsl>
#include <ShadingModel.glsl>
#include <Transform.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0,
       binding = 0,
       r11f_g11f_b10f) writeonly uniform image2D output_image;

layout(set = 0, binding = 1) uniform sampler2D gbuffer0_tex;
layout(set = 0, binding = 2) uniform sampler2D gbuffer1_tex;
layout(set = 0, binding = 3) uniform sampler2D gbuffer2_tex;
layout(set = 0, binding = 4) uniform sampler2D gbuffer3_tex;
layout(set = 0, binding = 5) uniform sampler2D depth_stencil_tex;
layout(set = 0, binding = 6) uniform sampler2D brdf_lut;
layout(set = 0, binding = 7) uniform samplerCube cube_map;

layout(set = 1, binding = 0) uniform Param {
    int width;
    int height;
    int point_light_count;
    int directional_light_count;
    mat4 I_P;
    mat4 I_V;
    vec3 env_randiance;
};

// Light position and direction are in view space
layout(set = 1, binding = 1) buffer PointLights {
    PointLight point_lights[];
};

layout(set = 1, binding = 2) buffer DirectionalLights {
    DirectionalLight directional_lights[];
};

vec3 get_env_radiance(vec3 v_ws, float lod) {
    return env_randiance * textureLod(cube_map, v_ws, lod).rgb;
}

vec3 get_env_irradiance(vec3 v_ws, float lod) {
    return get_env_radiance(v_ws, lod) * PI;
}

struct ShadingPoint {
    vec2 screen_uv;
    float depth01;
    vec3 pos_vs;
    // v_vs points from shading point to view point
    vec3 v_vs;
    vec3 v_ws;
};

ShadingPoint get_shading_point(vec2 uv) {
    ShadingPoint info;
    info.screen_uv = uv;
    info.depth01 = texture(depth_stencil_tex, uv).r;
    info.pos_vs = reconstruct_position_from_ss(I_P, uv, info.depth01);
    info.v_vs = -normalize(info.pos_vs);
    info.v_ws = transform_vector(I_V, info.v_vs);
    return info;
}

vec3 shade_background(vec3 v_ws) {
    return get_env_radiance(-v_ws, 0.0);
}

vec3 shade_unlit(GBuffer gbuffer) {
    return gbuffer.base_color.rgb;
}

vec3 shade_metallic_roughness_pbr(GBuffer gbuffer, ShadingPoint shading_point) {
    MetallicRoughnessPBRGBuffer material = decode_material(gbuffer.material);

    MetallicRoughnessPBR brdf;
    brdf.base_color = gbuffer.base_color.rgb;
    brdf.metallic = material.metallic;
    brdf.perceptual_roughness = material.perceptual_roughness;

    vec3 fd = diffuse_BRDF(brdf);

    // Extract geometry info
    vec3 pos_vs = shading_point.pos_vs;
    vec3 v_vs = shading_point.v_vs;
    vec3 v_ws = shading_point.v_ws;
    vec3 n_vs = normalize(gbuffer.normal_vs);

    vec3 direct_radiance = vec3(0.0);

    // Direct lighting
    for (int i = 0; i < point_light_count; i++) {
        vec3 lr, l_vs;
        radiance_to_point(point_lights[i], pos_vs, lr, l_vs);

        float NoL = clamp01(dot(n_vs, l_vs));
        vec3 fr = specular_BRDF(brdf, n_vs, v_vs, l_vs);
        direct_radiance += (fd + fr) * NoL * lr;
    }

    for (int i = 0; i < directional_light_count; i++) {
        vec3 lr, l_vs;
        radiance_to_point(directional_lights[i], pos_vs, lr, l_vs);

        float NoL = clamp01(dot(n_vs, l_vs));
        vec3 fr = specular_BRDF(brdf, n_vs, v_vs, l_vs);
        direct_radiance += (fd + fr) * NoL * lr;
    }

    float NoV = clamp01(dot(n_vs, v_vs));
    vec3 fe = environment_BRDF(brdf, brdf_lut, NoV);

    // Sample env irradiance
    vec3 n_ws = transform_vector(I_V, n_vs);
    vec3 reflect_dir_ws = reflect(-v_ws, n_ws);
    vec3 env_irradiance =
        get_env_irradiance(reflect_dir_ws, 8.0 * brdf.perceptual_roughness) *
        material.occlusion;
    vec3 indirect_radiance = (fd + fe) * env_irradiance;

    return direct_radiance + indirect_radiance + gbuffer.emission;
}

vec3 shade(GBuffer gbuffer, vec2 uv) {
    ShadingPoint shading_point = get_shading_point(uv);
    if (gbuffer.shading_model == SHADING_MODEL_BACKGROUND) {
        return shade_background(shading_point.v_ws);
    }
    if (gbuffer.shading_model == SHADING_MODEL_UNLIT) {
        return shade_unlit(gbuffer);
    }
    if (gbuffer.shading_model == SHADING_MODEL_METALLIC_ROUGHNESS_PBR) {
        return shade_metallic_roughness_pbr(gbuffer, shading_point);
    }
    return vec3(0);
}

void main() {
    ivec2 index = ivec2(gl_GlobalInvocationID.xy);
    if (index.x >= width || index.y >= height) {
        return;
    }

    vec2 inv_resolution = vec2(1.0 / width, 1.0 / height);
    vec2 uv = index_to_uv(vec2(index), inv_resolution);

    GBuffer gbuffer = decode_gbuffer(texture(gbuffer0_tex, uv),
                                     texture(gbuffer1_tex, uv),
                                     texture(gbuffer2_tex, uv),
                                     texture(gbuffer3_tex, uv));

    vec3 result = shade(gbuffer, uv);

    imageStore(output_image, index, vec4(result, 1.0));
}