#version 450 core

#include <GBuffer.glsl>
#include <Light.glsl>
#include <MetallicRoughnessPBR.glsl>
#include <Misc.glsl>
#include <ShadingModel.glsl>
#include <Transform.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0,
       binding = 0,
       r11f_g11f_b10f) writeonly uniform image2D output_image;

layout(set = 0, binding = 1) uniform sampler2D gbuffer0_tex;
layout(set = 0, binding = 2) uniform sampler2D gbuffer1_tex;
layout(set = 0, binding = 3) uniform sampler2D gbuffer2_tex;
layout(set = 0, binding = 4) uniform sampler2D gbuffer3_tex;
layout(set = 0, binding = 5) uniform sampler2D depth_stencil_tex;
layout(set = 0, binding = 6) uniform sampler2D brdf_lut;
layout(set = 0, binding = 7) uniform samplerCube cube_map;
layout(set = 0, binding = 8) uniform sampler2D hdr_environment_tex;
layout(set = 0, binding = 9) uniform sampler2D ssr_reflection;

layout(set = 1, binding = 0) uniform Param {
    int width;
    int height;
    int point_light_count;
    int directional_light_count;
    mat4 I_P;
    mat4 I_V;
    vec3 env_randiance_factor;
    int cube_map_mip_count;
};

// Light position and direction are in view space
layout(set = 1, binding = 1) buffer PointLights {
    PointLight point_lights[];
};

layout(set = 1, binding = 2) buffer DirectionalLights {
    DirectionalLight directional_lights[];
};

vec3 get_env_filtered_radiance(vec3 v_ws, float lod) {
    return env_randiance_factor * textureLod(cube_map, v_ws, lod).rgb;
}

vec3 get_diffuse_irradiance(vec3 n_ws) {
    return get_env_filtered_radiance(n_ws, cube_map_mip_count - 1) * PI;
}

vec3 get_glossy_irradiance(ShadingPoint sp,
                           vec3 n_ws,
                           float perceptual_roughness) {
    vec3 reflect_dir_ws = reflect(-sp.v_ws, n_ws);
    vec3 filtered_radiance = get_env_filtered_radiance(
        reflect_dir_ws, (cube_map_mip_count - 1) * perceptual_roughness);

    vec4 ssr = texture(ssr_reflection, sp.screen_uv);
    filtered_radiance = mix(filtered_radiance, ssr.rgb, ssr.a);

    return filtered_radiance * PI;
}

vec3 get_env_radiance_from_hdr_tex(vec3 v_ws) {
    vec2 uv = hdr_direction_to_uv(v_ws);
    return env_randiance_factor * texture(hdr_environment_tex, uv).rgb;
}

vec3 shade_background(vec3 v_ws) {
    return get_env_radiance_from_hdr_tex(-v_ws);
}

vec3 shade_unlit(GBuffer gbuffer) {
    return gbuffer.base_color.rgb;
}

vec3 shade_metallic_roughness_pbr(GBuffer gbuffer, ShadingPoint sp) {
    MetallicRoughnessPBR brdf = get_metallic_roughness_pbr(gbuffer);

    vec3 fd = diffuse_BRDF(brdf);

    // Extract geometry info
    vec3 pos_vs = sp.pos_vs;
    vec3 v_vs = sp.v_vs;
    vec3 v_ws = sp.v_ws;
    vec3 n_vs = normalize(gbuffer.normal_vs);

    vec3 direct_radiance = vec3(0.0);

    // Direct lighting
    for (int i = 0; i < point_light_count; i++) {
        vec3 lr, l_vs;
        radiance_to_point(point_lights[i], pos_vs, lr, l_vs);

        float NoL = clamp01(dot(n_vs, l_vs));
        vec3 fr = specular_BRDF(brdf, n_vs, v_vs, l_vs);
        direct_radiance += (fd + fr) * NoL * lr;
    }

    for (int i = 0; i < directional_light_count; i++) {
        vec3 lr, l_vs;
        radiance_to_point(directional_lights[i], pos_vs, lr, l_vs);

        float NoL = clamp01(dot(n_vs, l_vs));
        vec3 fr = specular_BRDF(brdf, n_vs, v_vs, l_vs);
        direct_radiance += (fd + fr) * NoL * lr;
    }

    // Sample env irradiance
    vec3 n_ws = transform_vector(I_V, n_vs);
    vec3 diffuse_env_irradiance = brdf.occlusion * get_diffuse_irradiance(n_ws);
    vec3 diffuse_indirect_radiance = fd * diffuse_env_irradiance;

    float NoV = clamp01(dot(n_vs, v_vs));
    vec3 fe = environment_BRDF(brdf, brdf_lut, NoV);
    vec3 glossy_env_irradiance =
        brdf.occlusion *
        get_glossy_irradiance(sp, n_ws, brdf.perceptual_roughness);
    vec3 glossy_indirect_radiance = fe * glossy_env_irradiance;

    return direct_radiance + diffuse_indirect_radiance +
           glossy_indirect_radiance + gbuffer.emission;
}

vec3 shade(GBuffer gbuffer, vec2 uv) {
    float depth01 = texture(depth_stencil_tex, uv).r;
    ShadingPoint sp = get_shading_point(uv, depth01, I_P, I_V);
    if (gbuffer.shading_model == SHADING_MODEL_BACKGROUND) {
        return shade_background(sp.v_ws);
    }
    if (gbuffer.shading_model == SHADING_MODEL_UNLIT) {
        return shade_unlit(gbuffer);
    }
    if (gbuffer.shading_model == SHADING_MODEL_METALLIC_ROUGHNESS_PBR) {
        return shade_metallic_roughness_pbr(gbuffer, sp);
    }
    return vec3(0);
}

void main() {
    ivec2 index = ivec2(gl_GlobalInvocationID.xy);
    if (index.x >= width || index.y >= height) {
        return;
    }

    vec2 inv_resolution = vec2(1.0 / width, 1.0 / height);
    vec2 uv = index_to_uv(vec2(index), inv_resolution);

    GBuffer gbuffer = decode_gbuffer(texture(gbuffer0_tex, uv),
                                     texture(gbuffer1_tex, uv),
                                     texture(gbuffer2_tex, uv),
                                     texture(gbuffer3_tex, uv));

    vec3 result = shade(gbuffer, uv);

    imageStore(output_image, index, vec4(result, 1.0));
}