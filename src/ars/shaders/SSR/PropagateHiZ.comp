#version 450 core

#include <Misc.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform sampler2D last_level;
layout(set = 0, binding = 1, r32f) writeonly uniform image2D cur_level;

void main() {
    ivec2 index = ivec2(gl_GlobalInvocationID.xy);
    ivec2 cur_level_size = imageSize(cur_level);
    ivec2 last_level_size = textureSize(last_level, 0);

    if (index.x >= cur_level_size.x || index.y >= cur_level_size.y) {
        return;
    }

    ivec2 index_in_last_level = index * 2;
    vec2 last_level_grid_size = 1.0 / last_level_size;
    vec2 last_level_uv = (index_in_last_level + 1) * last_level_grid_size;

    float max_depth01 =
        max_comp_value(textureGather(last_level, last_level_uv, 0));

    // For NPOT(none power of two) texture
    bool pad_width = (cur_level_size.x * 2 < last_level_size.x) &&
                     (index.x + 1 == cur_level_size.x);
    bool pad_height = (cur_level_size.y * 2 < last_level_size.y) &&
                      (index.y + 1 == cur_level_size.y);

    if (pad_width) {
        float pad_max_depth01 = max_comp_value(
            textureGather(last_level,
                          last_level_uv + vec2(last_level_grid_size.x, 0.0))
                .yz);
        max_depth01 = max(max_depth01, pad_max_depth01);
    }

    if (pad_height) {
        float pad_max_depth01 = max_comp_value(
            textureGather(last_level,
                          last_level_uv + vec2(0.0, last_level_grid_size.y))
                .xy);
        max_depth01 = max(max_depth01, pad_max_depth01);
    }

    if (pad_width && pad_height) {
        float pad_max_depth01 =
            texture(last_level, last_level_uv + 1.5 * last_level_grid_size).r;
        max_depth01 = max(max_depth01, pad_max_depth01);
    }

    imageStore(cur_level, index, vec4(max_depth01, 0, 0, 0));
}
